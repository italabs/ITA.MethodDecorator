using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

using MethodDecorator.Fody;

using Mono.Cecil;
using MethodDecorator.Fody.Interfaces;
using System.Text.RegularExpressions;
using Fody;
using MethodDecorator.Fody.Interfaces.Aspects;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using Mono.Collections.Generic;
using FieldAttributes = Mono.Cecil.FieldAttributes;
using MethodAttributes = Mono.Cecil.MethodAttributes;
using TypeAttributes = Mono.Cecil.TypeAttributes;

public class ModuleWeaver : BaseModuleWeaver
{
    private ReferenceFinder referenceFinder;

    public override void Execute()
    {
        this.referenceFinder = new ReferenceFinder(this);

        var decorator = new MethodDecorator.Fody.MethodDecorator(this.ModuleDefinition, this.referenceFinder);

        this.DecorateByType(decorator);
    }

    public override IEnumerable<string> GetAssembliesForScanning()
    {
        yield return "netstandard";
        yield return "mscorlib";
        yield return "System";
        yield return "System.Runtime";
        yield return "System.Core";
    }

    private void DecorateByType(MethodDecorator.Fody.MethodDecorator decorator)
    {
        var markerTypeDefinitions = this.FindMarkerTypes();

        // Look for rules in the assembly and module.
        var assemblyRules = FindAspectRules(this.ModuleDefinition.Assembly.CustomAttributes);
        var moduleRules = FindAspectRules(this.ModuleDefinition.CustomAttributes);

        // Read the top-level and nested types from this module
        foreach (var type in this.ModuleDefinition.Types.SelectMany(x => GetAllTypes(x)))
        {
            if (IsCompilerGenerated(type.CustomAttributes))
                continue;

            var aspectRuleApplications = new List<AspectRuleApplication>();
            var appliedAspects = new List<AspectInfo>();

            // Look for rules on the type and marker attributes
            var classRules = FindByMarkerType(markerTypeDefinitions, type.CustomAttributes)
                .Concat(FindAspectRules(type.CustomAttributes, true));

            // 1st pass: Loop through all methods in this type
            foreach (var method in type.Methods.Where(x => x.HasBody))
            {
                // Check whether method itself is generated by the compiler
                if (IsCompilerGenerated(method.CustomAttributes))
                {
                    // Check whether method belongs to the property and its property is generated by the compiler
                    var methodProperty = GetMethodProperty(method);
                    if (methodProperty == null || IsCompilerGenerated(methodProperty.CustomAttributes))
                    {
                        continue;
                    }
                }

                // Find any rules applied to the method.
                var methodRules = FindByMarkerType(markerTypeDefinitions, method.CustomAttributes)
                    .Concat(FindAspectRules(method.CustomAttributes, true));

                // Join together all the rules and give them an ordering number starting at 0 for
                // the highest level (assembly) to N as a lowest level (last attribute on the method)
                var allRules = assemblyRules
                    .Concat(moduleRules)
                    .Concat(classRules)
                    .Concat(methodRules)
                    .Select((Rule, ScopeOrdering) => new { Rule, ScopeOrdering });

                var orderedList = allRules
                                .Where(x => x.Rule.Match(type, method))
                                .OrderByDescending(x => x.Rule.AspectPriority)
                                .ThenByDescending(x => x.ScopeOrdering)
                                .GroupBy(x => x.Rule.MethodDecoratorAttribute.AttributeType);

                // Group the rules by the aspect type
                foreach (var aspectSet in orderedList)
                {
                    // Sort the rules in priority order (so that attributes applied to the
                    // method take precedence over the type, module then assembly)
                    // Then pick out the first rule - this tells us whether to include
                    // or exclude.

                    var rule = aspectSet
                                .OrderBy(x => x.Rule.AttributePriority)
                                .ThenByDescending(x => x.ScopeOrdering)
                                .Select(x => x.Rule)
                                .FirstOrDefault();

                    // If we have a rule and it isn't an exclusion.
                    if (rule != null && !rule.AttributeExclude)
                    {
                        var attributeTypeDefinition = rule.MethodDecoratorAttribute.AttributeType.Resolve();
                        var isInstanceScopedAspect = attributeTypeDefinition.Interfaces
                            .Any(x => x.InterfaceType.Resolve().FullName == typeof(IInstanceScopedAspect).FullName);

                        aspectRuleApplications.Add(new AspectRuleApplication(rule, method, isInstanceScopedAspect));
                    }
                }
            }

            // 2nd pass: If there are any rules to apply
            // TODO: consider making 1-pass decoration as it was before, with nested class generation on a first found aspect rule
            if (aspectRuleApplications.Any())
            {
                // Add nested class which will contain code for static initialization
                var aspectType = AddNestedType(type, "__fody$Aspects", referenceFinder.ObjectTypeRef);

                int n = 1;

                // Add instance-scoped aspect init method

                MethodDefinition initInstanceAspectsMethodDefinition = null;

                // Apply method decoration for each rule
                foreach (var application in aspectRuleApplications)
                {
                    n++;

                    // Add static fields for the aspect attribute and the method
                    var staticAttributeFieldName = "__fody$a" + n;
                    var staticAttributeFieldDefinition = AddStaticFieldDefinition(
                        aspectType,
                        staticAttributeFieldName,
                        application.Rule.MethodDecoratorAttribute.AttributeType);

                    var methodFieldName = "__fody$m" + n;
                    var methodFieldDefinition = AddStaticFieldDefinition(aspectType, methodFieldName, referenceFinder.MethodBaseTypeRef);

                    var instanceAttributeFieldDefinition = staticAttributeFieldDefinition;

                    if (application.IsInstanceScoped)
                    {
                        var instanceAttributeFieldName = "__fody$ia" + n;

                        instanceAttributeFieldDefinition = AddInstanceFieldDefinition(
                            type,
                            instanceAttributeFieldName,
                            application.Rule.MethodDecoratorAttribute.AttributeType);

                        // Decorate method using static fields added earlier
                        decorator.Decorate(
                            type,
                            application.Method,
                            application.Rule.MethodDecoratorAttribute,
                            application.Rule.ExplicitMatch,
                            instanceAttributeFieldDefinition,
                            methodFieldDefinition);

                        var attributeTypeDefinition = application.Rule.MethodDecoratorAttribute.AttributeType.Resolve();
                        var attributeTypeConstructor = attributeTypeDefinition.GetConstructors().FirstOrDefault(x => x.Parameters.Count == 0);

                        type.Module.ImportReference(attributeTypeConstructor);

                        if (initInstanceAspectsMethodDefinition == null)
                        {
                            initInstanceAspectsMethodDefinition = GenerateInitInstanceAspectsMethod(type);
                        }

                        var createInstanceMethodDefinition = referenceFinder.GetOptionalMethodReference(attributeTypeDefinition,
                            md => md.Name == "CreateInstance" && md.Parameters.Count == 1);

                        if (createInstanceMethodDefinition == null)
                            throw new WeavingException(String.Format("Missing CreateInstance method in the type implementing IInstanceScopedAspect: {0}", attributeTypeDefinition.Name));

                        var initInstructions = new [] {
                            Instruction.Create(OpCodes.Ldarg_0),
                            Instruction.Create(OpCodes.Ldsfld, staticAttributeFieldDefinition),
                            Instruction.Create(OpCodes.Ldarg_0),
                            Instruction.Create(OpCodes.Callvirt, createInstanceMethodDefinition),
                            Instruction.Create(OpCodes.Castclass, attributeTypeDefinition), 
                            Instruction.Create(OpCodes.Stfld, instanceAttributeFieldDefinition),
                        };

                        var processor = initInstanceAspectsMethodDefinition.Body.GetILProcessor();
                        var methodBodyFirstInstruction = initInstanceAspectsMethodDefinition.Body.Instructions.First();

                        processor.InsertBefore(methodBodyFirstInstruction, initInstructions);
                    }
                    else
                    {
                        // Decorate method using static fields added earlier
                        decorator.Decorate(
                            type,
                            application.Method,
                            application.Rule.MethodDecoratorAttribute,
                            application.Rule.ExplicitMatch,
                            instanceAttributeFieldDefinition,
                            methodFieldDefinition);
                    }

                    appliedAspects.Add(new AspectInfo
                    {
                        Attribute = application.Rule.MethodDecoratorAttribute,
                        Method = application.Method,
                        InstanceAttributeFieldDefinition = instanceAttributeFieldDefinition,
                        StaticAttributeFieldDefinition = staticAttributeFieldDefinition,
                        MethodFieldDefinition = methodFieldDefinition,
                        ExplicitMatch = application.Rule.ExplicitMatch
                    });
                }

                // Generate static constructor in the nested class
                GenerateStaticConstructor(aspectType, appliedAspects, referenceFinder);

                // Generate calls to instance-scoped initialization method in all constructors
                if (initInstanceAspectsMethodDefinition != null)
                {
                    foreach (var constructor in type.GetConstructors())
                    {
                        if (constructor.IsStatic)
                            continue;
                        
                        var processor = constructor.Body.GetILProcessor();

                        var callBase = constructor.Body.Instructions.FirstOrDefault(
                                i => (i.OpCode == OpCodes.Call) && (i.Operand is MethodReference) && ((MethodReference)i.Operand).Resolve().IsConstructor);

                        var methodBodyFirstInstruction = (callBase == null ? null : callBase.Next) ?? constructor.Body.Instructions.First();

                        processor.InsertBefore(methodBodyFirstInstruction, new[]
                        {
                            processor.Create(OpCodes.Ldarg_0),
                            processor.Create(OpCodes.Call, initInstanceAspectsMethodDefinition)
                        });
                    }
                }
            }
        }
    }

    private MethodDefinition GenerateInitInstanceAspectsMethod(TypeDefinition type)
    {
        var methodDefinition = new MethodDefinition("__fody$InitAspects", MethodAttributes.Private, referenceFinder.VoidTypeRef);

        var processor = methodDefinition.Body.GetILProcessor();
        processor.Append(processor.Create(OpCodes.Ret));

        type.Methods.Add(methodDefinition);
        return methodDefinition;
    }

    private IEnumerable<AspectRule> FindByMarkerType(
        IEnumerable<TypeDefinition> markerTypeDefinitions,
        Collection<CustomAttribute> customAttributes)
    {
        foreach (var attr in customAttributes)
        {
            var attributeTypeDef = attr.AttributeType.Resolve();

            foreach (var markerTypeDefinition in markerTypeDefinitions)
            {
                if (attributeTypeDef.Implements(markerTypeDefinition)
                    || attributeTypeDef.DerivesFrom(markerTypeDefinition)
                    || this.AreEquals(attributeTypeDef, markerTypeDefinition))
                {
                    yield return new AspectRule()
                    {
                        MethodDecoratorAttribute = attr,
                        AttributeExclude = false,
                        AttributePriority = 0,
                        AspectPriority = 0,
                        ExplicitMatch = true
                    };
                }
            }
        }
    }

    private IEnumerable<AttributeMethodInfo> FindAttributedMethods(IEnumerable<TypeDefinition> markerTypeDefintions)
    {
        return from topLevelType in this.ModuleDefinition.Types
               from type in GetAllTypes(topLevelType)
               from method in type.Methods
               where method.HasBody
               from attribute in method.CustomAttributes.Concat(method.DeclaringType.CustomAttributes)
               let attributeTypeDef = attribute.AttributeType.Resolve()
               from markerTypeDefinition in markerTypeDefintions
               where attributeTypeDef.Implements(markerTypeDefinition) ||
                     attributeTypeDef.DerivesFrom(markerTypeDefinition) ||
                     this.AreEquals(attributeTypeDef, markerTypeDefinition)
               select new AttributeMethodInfo
               {
                   CustomAttribute = attribute,
                   TypeDefinition = type,
                   MethodDefinition = method
               };
    }

    private IEnumerable<TypeDefinition> FindMarkerTypes()
    {
        var allAttributes = this.GetAttributes();

        var markerTypeDefinitions = (from type in allAttributes
                                     where HasCorrectMethods(type)
                                     && !type.Implements(typeof(IAspectMatchingRule).FullName)
                                     select type).ToList();

        return markerTypeDefinitions;
    }


    private IEnumerable<AspectRule> FindAspectRules(
        IEnumerable<CustomAttribute> attrs,
        bool explicitMatch = false)
    {
        return attrs
            .Where(attr => IsAspectMatchingRule(attr))
            .Select(attr => new AspectRule()
            {
                AttributeTargetTypes = GetAttributeProperty<string>(attr, "AttributeTargetTypes"),
                AttributeExclude = GetAttributeProperty<bool>(attr, "AttributeExclude"),
                AttributePriority = GetAttributeProperty<int>(attr, "AttributePriority"),
                AspectPriority = GetAttributeProperty<int>(attr, "AspectPriority"),
                MethodDecoratorAttribute = attr,
                ExplicitMatch = explicitMatch
            });
    }

    private T GetAttributeProperty<T>(CustomAttribute attr, string propertyName)
    {
        if (!attr.Properties.Any(x => x.Name == propertyName))
            return default(T);

        return (T)attr.Properties.First(x => x.Name == propertyName).Argument.Value;
    }

    private bool IsAspectMatchingRule(CustomAttribute x)
    {
        var typeDefinition = x.AttributeType.Resolve();

        return typeDefinition.Implements(typeof(IAspectMatchingRule).FullName);
    }

    private IEnumerable<TypeDefinition> GetAttributes()
    {
        var res = new List<TypeDefinition>();

        res.AddRange(this.ModuleDefinition.CustomAttributes.Select(c => c.AttributeType.Resolve()));
        res.AddRange(this.ModuleDefinition.Assembly.CustomAttributes.Select(c => c.AttributeType.Resolve()));

        if (this.ModuleDefinition.Runtime >= TargetRuntime.Net_4_0)
        {
            //will find if assembly is loaded
            var methodDecorator = Type.GetType("MethodDecorator.Fody.Interfaces.IMethodDecorator, ITA.MethodDecoratorInterfaces");

            //make using of MethodDecoratorEx assembly optional because it can break exists code
            if (null != methodDecorator)
            {

                res.AddRange(this.ModuleDefinition.Types.Where(c => c.Implements(methodDecorator.FullName)));
            }
        }

        return res;
    }

    private static bool HasCorrectMethods(TypeDefinition type)
    {
        return type.Methods.Any(IsOnEntryMethod) &&
               type.Methods.Any(IsOnExitMethod) &&
               type.Methods.Any(IsOnExceptionMethod);
    }

    private static bool IsOnEntryMethod(MethodDefinition m)
    {
        return m.Name == "OnEntry" && 
            (m.Parameters.Count == 0 ||
            (m.Parameters.Count == 1 && m.Parameters[0].ParameterType.FullName == typeof(MethodExecutionArgs).FullName));
    }

    private static bool IsOnExitMethod(MethodDefinition m)
    {
        return m.Name == "OnExit" &&
            (m.Parameters.Count == 0 ||
            (m.Parameters.Count == 1 && m.Parameters[0].ParameterType.FullName == typeof(MethodExecutionArgs).FullName));
    }

    private static bool IsOnExceptionMethod(MethodDefinition m)
    {
        return m.Name == "OnException" &&
            ((m.Parameters.Count == 1 && m.Parameters[0].ParameterType.FullName == typeof(Exception).FullName) ||
             (m.Parameters.Count == 2 &&
              m.Parameters[0].ParameterType.FullName == typeof(MethodExecutionArgs).FullName &&
              m.Parameters[1].ParameterType.FullName == typeof(Exception).FullName));
    }

    private bool AreEquals(TypeDefinition attributeTypeDef, TypeDefinition markerTypeDefinition)
    {
        return attributeTypeDef.FullName == markerTypeDefinition.FullName;
    }

    private static IEnumerable<TypeDefinition> GetAllTypes(TypeDefinition type)
    {
        yield return type;

        var allNestedTypes = from t in type.NestedTypes
                             from t2 in GetAllTypes(t)
                             select t2;

        foreach (var t in allNestedTypes)
            yield return t;
    }

    private static FieldDefinition AddStaticFieldDefinition(TypeDefinition type, string fieldName, TypeReference fieldType)
    {
        var fieldDefinition = new FieldDefinition(fieldName, FieldAttributes.Public | FieldAttributes.Static, fieldType);
        type.Fields.Add(fieldDefinition);
        return fieldDefinition;
    }

    private static FieldDefinition AddInstanceFieldDefinition(TypeDefinition type, string fieldName, TypeReference fieldType)
    {
        var fieldDefinition = new FieldDefinition(fieldName, FieldAttributes.Private, fieldType);
        type.Fields.Add(fieldDefinition);
        return fieldDefinition;
    }

    private static TypeDefinition AddNestedType(TypeDefinition type, string typeName, TypeReference baseType)
    {
        var nestedTypeDefinition = new TypeDefinition(string.Empty, typeName, TypeAttributes.NestedPrivate | TypeAttributes.Sealed, baseType);

        type.NestedTypes.Add(nestedTypeDefinition);

        return nestedTypeDefinition;
    }

    private void GenerateStaticConstructor(
        TypeDefinition type,
        List<AspectInfo> aspects,
        ReferenceFinder referenceFinder)
    {
        var staticConstructorDefinition = type.Methods.FirstOrDefault(x => x.Name == ".cctor");
        if (staticConstructorDefinition == null)
        {
            var methodAttributes = MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName;

            staticConstructorDefinition = new MethodDefinition(".cctor", methodAttributes, referenceFinder.VoidTypeRef);
            staticConstructorDefinition.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

            type.Methods.Add(staticConstructorDefinition);
        }

        var processor = staticConstructorDefinition.Body.GetILProcessor();
        var methodBodyFirstInstruction = staticConstructorDefinition.Body.Instructions.First();

        foreach (var aspect in aspects)
        {
            var initAttributeVariable = GetAttributeInstanceInstructions(
                processor,
                aspect.Attribute,
                aspect.Method,
                aspect.StaticAttributeFieldDefinition,
                aspect.MethodFieldDefinition,
                aspect.ExplicitMatch,
                referenceFinder);

            processor.InsertBefore(methodBodyFirstInstruction, initAttributeVariable);
        }
    }

    private IEnumerable<Instruction> GetAttributeInstanceInstructions(
        ILProcessor processor,
        ICustomAttribute attribute,
        MethodDefinition method,
        FieldDefinition attributeFieldDefinition,
        FieldDefinition methodFieldDefinition,
        bool explicitMatch,
        ReferenceFinder referenceFinder)
    {

        var getMethodFromHandleRef = referenceFinder.GetMethodReference(referenceFinder.MethodBaseTypeRef,
            md => md.Name == "GetMethodFromHandle" && md.Parameters.Count == 2);

        var getTypeof = referenceFinder.GetMethodReference(referenceFinder.SystemTypeRef, md => md.Name == "GetTypeFromHandle");
        var ctor = referenceFinder.GetMethodReference(referenceFinder.ActivatorTypeRef, md => md.Name == "CreateInstance" &&
                                                                                        md.Parameters.Count == 1);

        var getCustomAttrs = referenceFinder.GetMethodReference(referenceFinder.AttributeTypeRef,
            md => md.Name == "GetCustomAttributes" &&
            md.Parameters.Count == 2 &&
            md.Parameters[0].ParameterType.FullName == typeof(MemberInfo).FullName &&
            md.Parameters[1].ParameterType.FullName == typeof(Type).FullName);
        
        var oInstructions = new List<Instruction>
                {
                    processor.Create(OpCodes.Nop),

                    processor.Create(OpCodes.Ldtoken, method),
                    processor.Create(OpCodes.Ldtoken, method.DeclaringType),
                    processor.Create(OpCodes.Call, getMethodFromHandleRef),      // Push method onto the stack, GetMethodFromHandle, result on stack
                    processor.Create(OpCodes.Stsfld, methodFieldDefinition),     // Store method in __fody$method

                    processor.Create(OpCodes.Nop),
                };

        if (explicitMatch &&
            method.CustomAttributes.Any(m => m.AttributeType.Equals(attribute.AttributeType)))
        {
            oInstructions.AddRange(new Instruction[]
                {
                        processor.Create(OpCodes.Ldsfld, methodFieldDefinition),
                        processor.Create(OpCodes.Ldtoken, attribute.AttributeType),
                        processor.Create(OpCodes.Call,getTypeof),
                        processor.Create(OpCodes.Call,getCustomAttrs),

                        processor.Create(OpCodes.Dup),
                        processor.Create(OpCodes.Ldlen),
                        processor.Create(OpCodes.Ldc_I4_1),
                        processor.Create(OpCodes.Sub),

                        processor.Create(OpCodes.Ldelem_Ref),

                        processor.Create(OpCodes.Castclass, attribute.AttributeType),
                        processor.Create(OpCodes.Stsfld, attributeFieldDefinition),
                });
        }
        else if (explicitMatch &&
                 method.DeclaringType.CustomAttributes.Any(m => m.AttributeType.Equals(attribute.AttributeType)))
        {
            oInstructions.AddRange(new Instruction[]
                {
                        processor.Create(OpCodes.Ldtoken, method.DeclaringType),
                        processor.Create(OpCodes.Call,getTypeof),
                        processor.Create(OpCodes.Ldtoken, attribute.AttributeType),
                        processor.Create(OpCodes.Call,getTypeof),
                        processor.Create(OpCodes.Call,getCustomAttrs),

                        processor.Create(OpCodes.Dup),
                        processor.Create(OpCodes.Ldlen),
                        processor.Create(OpCodes.Ldc_I4_1),
                        processor.Create(OpCodes.Sub),

                        processor.Create(OpCodes.Ldelem_Ref),

                        processor.Create(OpCodes.Castclass, attribute.AttributeType),
                        processor.Create(OpCodes.Stsfld, attributeFieldDefinition),
                });
        }
        else
        {
            oInstructions.AddRange(new Instruction[]
                {
                        processor.Create(OpCodes.Ldtoken, attribute.AttributeType),
                        processor.Create(OpCodes.Call,getTypeof),
                        processor.Create(OpCodes.Call,ctor),
                        processor.Create(OpCodes.Castclass, attribute.AttributeType),
                        processor.Create(OpCodes.Stsfld, attributeFieldDefinition),
                });
        }

        var runtimeInitializeMethodRef = referenceFinder.GetOptionalMethodReference(attribute.AttributeType,
               md => md.Name == "RuntimeInitialize" && md.Parameters.Count == 1 && md.Parameters[0].ParameterType.FullName == typeof(MethodBase).FullName);

        if (runtimeInitializeMethodRef != null)
        {
            oInstructions.AddRange(new []
            {
                processor.Create(OpCodes.Ldsfld, attributeFieldDefinition),
                processor.Create(OpCodes.Ldsfld, methodFieldDefinition),
                processor.Create(OpCodes.Callvirt, runtimeInitializeMethodRef)
        });
        }

        return oInstructions;
    }

    private static bool IsCompilerGenerated(IEnumerable<CustomAttribute> attributes)
    {
        return attributes.Any(x => x.AttributeType.FullName == typeof(CompilerGeneratedAttribute).FullName);
    }

    private static PropertyDefinition GetMethodProperty(MethodDefinition method)
    {
        if (method.IsGetter)
            return method.DeclaringType.Properties.FirstOrDefault(x => x.GetMethod == method);

        if (method.IsSetter)
            return method.DeclaringType.Properties.FirstOrDefault(x => x.SetMethod == method);

        return null;
    }

    private class HostAttributeMapping
    {
        public TypeDefinition[] AttribyteTypes { get; set; }
        public CustomAttribute HostAttribute { get; set; }
    }

    private class AttributeMethodInfo
    {
        public TypeDefinition TypeDefinition { get; set; }
        public MethodDefinition MethodDefinition { get; set; }
        public CustomAttribute CustomAttribute { get; set; }
    }

    private class AspectRule
    {

        private const string _regexPrefix = "regex:";

        private string _attributeTargetTypes;
        private Regex _matchRegex;

        public string AttributeTargetTypes
        {
            get { return _attributeTargetTypes; }
            set
            {
                _attributeTargetTypes = value;

                if (value != null)
                {
                    string pattern;
                    if (value.StartsWith(_regexPrefix))
                    {
                        pattern = value.Substring(_regexPrefix.Length);
                    }
                    else
                    {
                        pattern = String.Join("|",          // "OR" each comma-separated item
                            value.Split(new[] { ',' })      // (split by comma)
                                .Select(x => x.Trim(" \t\r\n".ToCharArray()))
                                .Select(t =>
                                    "^"                     // Anchor to start
                                    + String.Join(".*",         // Convert * to .*
                                        t.Split(new[] { '*' })
                                        .Select(x => Regex.Escape(x)))  // Convert '.' into '\.'
                                    + "$"));                // Anchor to end
                    }

                    _matchRegex = new Regex(pattern);
                }
                else
                {
                    _matchRegex = null;
                }
            }
        }

        public bool AttributeExclude { get; set; }
        public int AttributePriority { get; set; }
        public int AspectPriority { get; set; }
        public CustomAttribute MethodDecoratorAttribute { get; set; }
        public bool ExplicitMatch { get; internal set; }

        internal bool Match(TypeDefinition type, MethodDefinition method)
        {
            if (this.AttributeTargetTypes == null)
                return this.ExplicitMatch;

            string completeMethodName = type.Namespace + "." + type.Name + "." + method.Name;

            var result = _matchRegex.IsMatch(completeMethodName);
            return result;
        }
    }

    private class AspectRuleApplication
    {
        public AspectRuleApplication(AspectRule rule, MethodDefinition method, bool isInstanceScopedAspect)
        {
            Rule = rule;
            Method = method;
            IsInstanceScoped = isInstanceScopedAspect;
        }

        public AspectRule Rule { get; set; }
        public MethodDefinition Method { get; set; }
        public bool IsInstanceScoped { get; set; }
    }

    private class AspectInfo
    {
        public CustomAttribute Attribute { get; set; }
        public MethodDefinition Method { get; set; }
        public FieldDefinition InstanceAttributeFieldDefinition { get; set; }
        public FieldDefinition StaticAttributeFieldDefinition { get; set; }
        public FieldDefinition MethodFieldDefinition { get; set; }
        public bool ExplicitMatch { get; set; }
    }
}
